<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>立方体の切断：ABCラベル付</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background: #eceff1; }
        #ui-panel {
            position: absolute; top: 20px; left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px; border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            width: 180px; z-index: 100;
        }
        .control-group { display: flex; align-items: center; gap: 8px; cursor: pointer; }
        h3 { margin: 0 0 10px 0; font-size: 1rem; color: #333; }
        .info { font-size: 0.75rem; color: #666; margin-top: 10px; line-height: 1.4; }
        
        /* ラベルのスタイル */
        .point-label {
            color: #007bff;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 1px 1px 2px white, -1px -1px 2px white;
            pointer-events: none; /* ラベルがドラッグの邪魔をしないように */
        }
    </style>
</head>
<body>

    <div id="ui-panel">
        <h3>表示設定</h3>
        <label class="control-group">
            <input type="checkbox" id="showSection" checked> 断面を表示
        </label>
        <div class="info">
            • <b>点A, B, C</b>をドラッグ<br>
            • 背景ドラッグで視点回転
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // シーン設定
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(4, 4, 6);

        // レンダラー設定
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // ラベル用レンダラー
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        document.body.appendChild(labelRenderer.domElement);

        const controls = new OrbitControls(camera, labelRenderer.domElement);
        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(5, 10, 7);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        // 立方体データ
        const size = 2;
        const half = size / 2;
        const vertices = [
            [-half,-half,-half], [half,-half,-half], [half,half,-half], [-half,half,-half],
            [-half,-half,half], [half,-half,half], [half,half,half], [-half,half,half]
        ];
        const edgeIndices = [
            [0,1], [1,2], [2,3], [3,0], [4,5], [5,6], [6,7], [7,4], [0,4], [1,5], [2,6], [3,7]
        ];

        const cube = new THREE.Mesh(
            new THREE.BoxGeometry(size, size, size),
            new THREE.MeshPhongMaterial({ color: 0x34495e, transparent: true, opacity: 0.15, side: THREE.DoubleSide })
        );
        scene.add(cube);
        scene.add(new THREE.LineSegments(new THREE.EdgesGeometry(cube.geometry), new THREE.LineBasicMaterial({ color: 0x000000 })));

        // 点と断面
        let sectionMesh;
        const draggablePoints = [];
        const labels = ['A', 'B', 'C'];
        const pointData = [
            { edgeIdx: 0, ratio: 0.5 },
            { edgeIdx: 9, ratio: 0.5 },
            { edgeIdx: 7, ratio: 0.5 }
        ];

        function createDraggablePoint(data, index) {
            const mesh = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 24, 24),
                new THREE.MeshBasicMaterial({ color: 0x007bff })
            );
            mesh.userData = { index: index };
            
            // ラベルの作成
            const div = document.createElement('div');
            div.className = 'point-label';
            div.textContent = labels[index];
            const label = new CSS2DObject(div);
            label.position.set(0, 0.3, 0); // 点の少し上に表示
            mesh.add(label);

            scene.add(mesh);
            draggablePoints.push(mesh);
            updatePointPosition(mesh, data.edgeIdx, data.ratio);
        }

        function updatePointPosition(mesh, edgeIdx, ratio) {
            const [sIdx, eIdx] = edgeIndices[edgeIdx];
            const start = new THREE.Vector3(...vertices[sIdx]);
            const end = new THREE.Vector3(...vertices[eIdx]);
            mesh.position.lerpVectors(start, end, ratio);
        }

        pointData.forEach((d, i) => createDraggablePoint(d, i));

        // ドラッグ
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedPoint = null;

        // ラベルレンダラーのDOMに対してイベントを貼る（controlsと共通にするため）
        labelRenderer.domElement.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);

        function onMouseDown(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(draggablePoints);
            if (intersects.length > 0) {
                selectedPoint = intersects[0].object;
                controls.enabled = false;
            }
        }

        function onMouseMove(e) {
            if (!selectedPoint) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const edgeIdx = pointData[selectedPoint.userData.index].edgeIdx;
            const [sIdx, eIdx] = edgeIndices[edgeIdx];
            const start = new THREE.Vector3(...vertices[sIdx]);
            const end = new THREE.Vector3(...vertices[eIdx]);
            const line = new THREE.Line3(start, end);
            const target = new THREE.Vector3();
            line.closestPointToPoint(raycaster.ray.at(camera.position.distanceTo(selectedPoint.position), new THREE.Vector3()), true, target);
            
            selectedPoint.position.copy(target);
            // --- 頂点進入制限ロジック ---
            const margin = 0.001; // 頂点から離す距離（微調整可能）
            const distFromStart = start.distanceTo(target);
            const distFromEnd = end.distanceTo(target);
            const fullLen = start.distanceTo(end);

            if (distFromStart < margin) {
                // 始点に近い場合、少しだけ終点側にずらす
                target.lerpVectors(start, end, margin / fullLen);
            } else if (distFromEnd < margin) {
                // 終点に近い場合、少しだけ始点側にずらす
                target.lerpVectors(start, end, 1 - (margin / fullLen));
            }
            // ----------------------------

            selectedPoint.position.copy(target);
            updateSection();
        }

        function onMouseUp() {
            selectedPoint = null;
            controls.enabled = true;
        }

        function updateSection() {
    if (sectionMesh) scene.remove(sectionMesh);
    if (!document.getElementById('showSection').checked) return;

    // A, B, C の位置を正確に取得
    const p1 = draggablePoints[0].position.clone();
    const p2 = draggablePoints[1].position.clone();
    const p3 = draggablePoints[2].position.clone();

    // 1. 法線ベクトルの計算
    const v1 = new THREE.Vector3().subVectors(p2, p1);
    const v2 = new THREE.Vector3().subVectors(p3, p1);
    let normal = new THREE.Vector3().crossVectors(v1, v2).normalize();

    // 3点が重なっているか一直線上の場合の救済措置
    if (normal.lengthSq() < 0.0001) {
        normal.set(0, 1, 0); // 仮の法線
    }

    const d = normal.dot(p1);
    const intersections = [];

    // 2. A, B, C 自体をまず交点候補として確実に登録する
    // これにより「頂点にあるから無視される」ことを防ぎます
    [p1, p2, p3].forEach(p => {
        if (!intersections.some(existing => existing.distanceTo(p) < 0.01)) {
            intersections.push(p.clone());
        }
    });

    // 3. 全ての辺との交点をチェック
    edgeIndices.forEach(([sIdx, eIdx]) => {
        const start = new THREE.Vector3(...vertices[sIdx]);
        const end = new THREE.Vector3(...vertices[eIdx]);

        const d1 = normal.dot(start) - d;
        const d2 = normal.dot(end) - d;

        // 平面が辺を横切っている場合
        if (d1 * d2 < -1e-7) { 
            const t = d1 / (d1 - d2);
            const intersect = new THREE.Vector3().lerpVectors(start, end, t);
            if (!intersections.some(p => p.distanceTo(intersect) < 0.01)) {
                intersections.push(intersect);
            }
        } 
        // 頂点がちょうど平面上にある場合（より広い許容範囲で判定）
        else {
            if (Math.abs(d1) < 1e-4) {
                if (!intersections.some(p => p.distanceTo(start) < 0.01)) intersections.push(start.clone());
            }
            if (Math.abs(d2) < 1e-4) {
                if (!intersections.some(p => p.distanceTo(end) < 0.01)) intersections.push(end.clone());
            }
        }
    });

    // 4. 多角形の構築
    if (intersections.length >= 3) {
        const center = new THREE.Vector3(0, 0, 0);
        intersections.forEach(p => center.add(p));
        center.divideScalar(intersections.length);
        
        const xAxis = new THREE.Vector3().subVectors(intersections[0], center).normalize();
        const yAxis = new THREE.Vector3().crossVectors(normal, xAxis).normalize();
        
        intersections.sort((a, b) => {
            const da = new THREE.Vector3().subVectors(a, center);
            const db = new THREE.Vector3().subVectors(b, center);
            return Math.atan2(da.dot(yAxis), da.dot(xAxis)) - Math.atan2(db.dot(yAxis), db.dot(xAxis));
        });

        const geom = new THREE.BufferGeometry().setFromPoints(intersections);
        const indices = [];
        for (let i = 1; i < intersections.length - 1; i++) {
            indices.push(0, i, i + 1);
        }
        geom.setIndex(indices);
        
        sectionMesh = new THREE.Mesh(
            geom, 
            new THREE.MeshPhongMaterial({ 
                color: 0xf39c12, 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0.7,
                depthWrite: false 
            })
        );
        scene.add(sectionMesh);
    }
}


        document.getElementById('showSection').addEventListener('change', updateSection);

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }
        updateSection();
        animate();

        window.addEventListener('resize', () => {
            const w = window.innerWidth;
            const h = window.innerHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
            labelRenderer.setSize(w, h);
        });
    </script>
</body>
</html>